local TweenService = game:GetService("TweenService")
local Storage = game:WaitForChild("ReplicatedStorage")
local Bindable = Storage:WaitForChild("Bindable")
local Player = game.Players.LocalPlayer

local NotificationsAmount = 0

local module = {}

function module:ResizeScrollingFrameCanvasSize(ScrollingFrame, UILayout, toAdd)
	if ScrollingFrame == nil then
		return error("[Ulysses Util]: 'ScrollingFrame' is missing!")
	elseif not ScrollingFrame:IsA("ScrollingFrame") then
		return error("[Ulysses Util]: 'ScrollingFrame' must be a ScrollingFrame!")
	end
	
	if UILayout == nil then
		return error("[Ulysses Util]: 'UILayout' is missing!")
	elseif not UILayout:IsA("UIListLayout") then
		return error("[Ulysses Util]: 'UILayout' must be a UIListLayout!")
	end
	
	if toAdd == nil then
		toAdd = 0
	elseif typeof(toAdd) ~= "number" then
		return error("[Ulysses Util]: 'toAdd' must be a number!")
	end
	
	if ScrollingFrame.ScrollingDirection == Enum.ScrollingDirection.XY then
		
	end
	
	if ScrollingFrame.ScrollingDirection == Enum.ScrollingDirection.XY then
		ScrollingFrame.CanvasSize = UDim2.new(0, ScrollingFrame.UIListLayout.AbsoluteContentSize.X + toAdd, 0, ScrollingFrame.UIListLayout.AbsoluteContentSize.Y + toAdd)
	elseif ScrollingFrame.ScrollingDirection == Enum.ScrollingDirection.X then
		ScrollingFrame.CanvasSize = UDim2.new(0, ScrollingFrame.UIListLayout.AbsoluteContentSize.X + toAdd, 0, 0)
	elseif ScrollingFrame.ScrollingDirection == Enum.ScrollingDirection.Y then
		ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, ScrollingFrame.UIListLayout.AbsoluteContentSize.Y + toAdd)
	end
end

function module:SetCameraTo(Camera, Target)
	if Camera == nil then
		return error("[Ulysses Util]: 'Camera' is missing!")
	elseif not Camera:IsA("Camera") then
		return error("[Ulysses Util]: 'Camera' must be a camera!")
	end
	
	if Target == nil then
		return error("[Ulysses Util]: 'Target' is missing!")
	end
	
	Camera.CameraSubject = Target
end

function module:TeleportTo(Target, TargetDestination, toAdd, isTween)
	if Target == nil then
		return error("[Ulysses Util]: 'Target' is missing!")
	end
	
	if TargetDestination == nil then
		return error("[Ulysses Util]: 'TargetDestination' is missing!")
	end
	
	if toAdd == nil then
		return error("[Ulysses Util]: 'toAdd' is missing!")
	elseif typeof(toAdd) ~= "Vector3" then
		return error("[Ulysses Util]: 'toAdd' must be a Vector3!")
	end
	
	if isTween == nil then
		isTween = false
	elseif typeof(isTween) ~= "boolean" then
		return error("[Ulysses Util]: 'Camera' must be a boolean!")
	end
	
	if isTween == true then
		TweenService:Create(Target, TweenInfo.new(.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0), { CFrame = CFrame.new(TargetDestination.Position) + toAdd }):Play()	
	else
		Target.CFrame = CFrame.new(TargetDestination.Position) + toAdd
	end
end

function module:GetNearestEnemy(target, world)
	if target == nil then
		return error("[Ulysses Utilities]: 'target' is missing!")
	end

	if world == nil then
		return error("[Ulysses Utilities]: 'world' is missing!")
	end

	local Character = Player.Character
	local HumanoidRootPart = Character and Character:FindFirstChild("HumanoidRootPart")

	if not (Character or HumanoidRootPart) then
		return
	end

	local Distance = 99
	local Target = nil

	for i,v in pairs(workspace.Worlds[world].Enemies:GetChildren()) do
		if v.Name == target and v:FindFirstChild("HumanoidRootPart") then
			local TargetHRP = v.HumanoidRootPart.Position
			local NewDistance = math.floor((TargetHRP - Player.Character.Head.Position).Magnitude)

			if NewDistance < Distance then
				Target = v
			end
		end
	end

	return Target
end

function module:SendPetsToEnemy(target)
	if target == nil then
		return error("[Ulysses Utilities]: 'target' is missing!")
	end

	for i, v in pairs(workspace.Pets:GetChildren()) do
		if v.Data.Owner.Value == Player then
			Bindable.SendPet:Fire(target, false)
		end
	end	
end

function module:CreateSlider(minvalue, maxvalue, sliderbtn, sliderframe, valuelabel, slidercont, callback)
	minvalue = minvalue or 0
	maxvalue = maxvalue or 100
	callback = callback or function() end

	local sliderbutton = sliderbtn
	local sliderframe = sliderframe
	local value = valuelabel or nil
	local moveconnection
	local releaseconnection
	local slidercontainer = slidercont

	local mouse = game.Players.LocalPlayer:GetMouse()
	local uis = game:GetService("UserInputService")
	local Value

	sliderbutton.MouseButton1Down:Connect(function()
		Value = math.floor((((tonumber(maxvalue) - tonumber(minvalue)) / slidercontainer.AbsoluteSize.X) * sliderframe.AbsoluteSize.X) + tonumber(minvalue)) or 0
		pcall(function()
			callback(Value)
		end)
		sliderframe.Size = UDim2.new(0, math.clamp(mouse.X - sliderframe.AbsolutePosition.X, 0, slidercontainer.AbsoluteSize.X), 0, slidercontainer.AbsoluteSize.Y)
		moveconnection = mouse.Move:Connect(function()
			value.Text = Value
			Value = math.floor((((tonumber(maxvalue) - tonumber(minvalue)) / slidercontainer.AbsoluteSize.X) * sliderframe.AbsoluteSize.X) + tonumber(minvalue))
			pcall(function()
				callback(Value)
			end)
			sliderframe.Size = UDim2.new(0, math.clamp(mouse.X - sliderframe.AbsolutePosition.X, 0, slidercontainer.AbsoluteSize.X), 0, slidercontainer.AbsoluteSize.Y)
		end)
		releaseconnection = uis.InputEnded:Connect(function(Mouse)
			if Mouse.UserInputType == Enum.UserInputType.MouseButton1 then
				Value = math.floor((((tonumber(maxvalue) - tonumber(minvalue)) / slidercontainer.AbsoluteSize.X) * sliderframe.AbsoluteSize.X) + tonumber(minvalue))
				pcall(function()
					callback(Value)
				end)
				sliderframe.Size = UDim2.new(0, math.clamp(mouse.X - sliderframe.AbsolutePosition.X, 0, slidercontainer.AbsoluteSize.X), 0, slidercontainer.AbsoluteSize.Y)
				moveconnection:Disconnect()
				releaseconnection:Disconnect()
			end
		end)
	end)
end

function module:InitNotificationSystem()
	local NotificationCont = {}
	local Gui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("UlyssesNotifications")

	if not Gui then
		local UlyssesNotifications = Instance.new("ScreenGui")
		local NotifcationContainer = Instance.new("Frame")
		local UIListLayout = Instance.new("UIListLayout")

		UlyssesNotifications.Name = "UlyssesNotifications"
		UlyssesNotifications.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
		UlyssesNotifications.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

		NotifcationContainer.Name = "NotifcationContainer"
		NotifcationContainer.Parent = UlyssesNotifications
		NotifcationContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		NotifcationContainer.Position = UDim2.new(0, 0, 0.986622095, -590)
		NotifcationContainer.Size = UDim2.new(0, 301, 0, 598)
		NotifcationContainer.BackgroundTransparency = 1

		UIListLayout.Parent = NotifcationContainer
		UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom	
		UIListLayout.Padding = UDim.new(0, 8)
		UIListLayout.SortOrder = Enum.SortOrder.Name
	end

	function NotificationCont:SendNotification(HeaderText, HeaderTextColor, NotifText, NotifColor, Duration, isInLeft)
		if HeaderText == nil then
			HeaderText = "Notification"
		end

		if HeaderTextColor == nil then
			return error("[Ulysses Notifications]: 'HeaderTextColor' is missing!")
		elseif typeof(HeaderTextColor) ~= "Color3" then
			return error("[Ulysses Notifications]: 'HeaderTextColor' must be a Color3!")
		end

		if NotifText == nil then
			NotifText = "No content provided."
		end

		if NotifColor == nil then
			return error("[Ulysses Notifications]: 'NotifTextColor' is missing!")
		elseif typeof(NotifColor) ~= "Color3" then
			return error("[Ulysses Notifications]: 'NotifTextColor' must be a Color3!")
		end

		if Duration == nil then
			return error("[Ulysses Notifications]: 'Duration' is missing!")
		elseif typeof(Duration) ~= "number" then
			return error("[Ulysses Notifications]: 'Duration' must be a number!")
		end

		if isInLeft == nil then
			isInLeft = false
		elseif typeof(isInLeft) ~= "boolean" then
			return error("[Ulysses Notifications]: 'isInLeft' must be a boolean!")
		end

		spawn(function()
			NotificationsAmount = NotificationsAmount + 1

			local Notification = Instance.new("Frame")
			local Frame = Instance.new("Frame")
			local UICorner = Instance.new("UICorner")
			local NotifHeaderText = Instance.new("TextLabel")
			local NotifMessage = Instance.new("TextLabel")
			local UICorner_2 = Instance.new("UICorner")
			local UIListLayout = Instance.new("UIListLayout")

			Notification.Name = "Notification".. NotificationsAmount
			Notification.Parent = game.Players.LocalPlayer.PlayerGui.UlyssesNotifications.NotifcationContainer
			Notification.BackgroundColor3 = NotifColor
			Notification.Position = UDim2.new(0.0341750011, 0, 0.884544909, 0)
			Notification.Size = UDim2.new(0, 280, 0, 63)
			Notification.BackgroundTransparency = 1

			Frame.Parent = Notification
			Frame.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
			Frame.Position = UDim2.new(0.0250000004, 0, -0.00355166476, 0)
			Frame.Size = UDim2.new(0, 267, 0, 63)
			Frame.BackgroundTransparency = 1

			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = Frame

			NotifHeaderText.Name = "NotifHeaderText"
			NotifHeaderText.Parent = Frame
			NotifHeaderText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NotifHeaderText.BackgroundTransparency = 1.000
			NotifHeaderText.Position = UDim2.new(0, 0, 0, 1)
			NotifHeaderText.Size = UDim2.new(0, 267, 0, 21)
			NotifHeaderText.Font = Enum.Font.Highway
			NotifHeaderText.Text = HeaderText
			NotifHeaderText.TextColor3 = HeaderTextColor
			NotifHeaderText.TextScaled = true
			NotifHeaderText.TextSize = 14.000
			NotifHeaderText.TextWrapped = true
			NotifHeaderText.TextTransparency = 1

			NotifMessage.Name = "NotifMessage"
			NotifMessage.Parent = Frame
			NotifMessage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NotifMessage.BackgroundTransparency = 1.000
			NotifMessage.Position = UDim2.new(0, 0, 0.398999989, 0)
			NotifMessage.Size = UDim2.new(0, 266, 0, 38)
			NotifMessage.Font = Enum.Font.Highway
			NotifMessage.Text = NotifText
			NotifMessage.TextColor3 = Color3.fromRGB(255, 255, 255)
			NotifMessage.TextScaled = true
			NotifMessage.TextSize = 14.000
			NotifMessage.TextWrapped = true
			NotifMessage.TextTransparency = 1

			UICorner_2.CornerRadius = UDim.new(0, 10)
			UICorner_2.Parent = Notification

			UIListLayout.Parent = Notification
			UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

			local s = TweenService:Create(Notification, TweenInfo.new(.5), { BackgroundTransparency = 0 })
			TweenService:Create(Frame, TweenInfo.new(.5), { BackgroundTransparency = 0 }):Play()
			TweenService:Create(NotifHeaderText, TweenInfo.new(.5), { TextTransparency = 0 }):Play()
			TweenService:Create(NotifMessage, TweenInfo.new(.5), { TextTransparency = 0 }):Play()
			s:Play()

			s.Completed:Wait()

			wait(Duration)

			local w = TweenService:Create(Notification, TweenInfo.new(.5), { BackgroundTransparency = 1 })
			TweenService:Create(Frame, TweenInfo.new(.5), { BackgroundTransparency = 1 }):Play()
			TweenService:Create(NotifHeaderText, TweenInfo.new(.5), { TextTransparency = 1 }):Play()
			TweenService:Create(NotifMessage, TweenInfo.new(.5), { TextTransparency = 1 }):Play()
			w:Play()

			w.Completed:Wait()

			Notification:Destroy()
		end)
	end

	return NotificationCont
end

function module:EnableFreecam()
	function sandbox(var,func)
		local env = getfenv(func)
		local newenv = setmetatable({},{
			__index = function(self,k)
				if k=="script" then
					return var
				else
					return env[k]
				end
			end,
		})
		setfenv(func,newenv)
		return func
	end
	cors = {}
	mas = Instance.new("Model",game:GetService("Lighting"))
	LocalScript0 = Instance.new("LocalScript")
	LocalScript0.Name = "FreeCamera"
	LocalScript0.Parent = mas
	table.insert(cors,sandbox(LocalScript0,function()
		-----------------------------------------------------------------------
		-- Freecam
		-- Cinematic free camera for spectating and video production.
		------------------------------------------------------------------------

		local pi    = math.pi
		local abs   = math.abs
		local clamp = math.clamp
		local exp   = math.exp
		local rad   = math.rad
		local sign  = math.sign
		local sqrt  = math.sqrt
		local tan   = math.tan

		local ContextActionService = game:GetService("ContextActionService")
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local StarterGui = game:GetService("StarterGui")
		local UserInputService = game:GetService("UserInputService")

		local LocalPlayer = Players.LocalPlayer
		if not LocalPlayer then
			Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
			LocalPlayer = Players.LocalPlayer
		end

		local Camera = workspace.CurrentCamera
		workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			local newCamera = workspace.CurrentCamera
			if newCamera then
				Camera = newCamera
			end
		end)

		------------------------------------------------------------------------

		local TOGGLE_INPUT_PRIORITY = Enum.ContextActionPriority.Low.Value
		local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value
		local FREECAM_MACRO_KB = {Enum.KeyCode.LeftShift, Enum.KeyCode.P}

		local NAV_GAIN = Vector3.new(1, 1, 1)*64
		local PAN_GAIN = Vector2.new(0.75, 1)*8
		local FOV_GAIN = 300

		local PITCH_LIMIT = rad(90)

		local VEL_STIFFNESS = 1.5
		local PAN_STIFFNESS = 1.0
		local FOV_STIFFNESS = 4.0

		------------------------------------------------------------------------

		local Spring = {} do
			Spring.__index = Spring

			function Spring.new(freq, pos)
				local self = setmetatable({}, Spring)
				self.f = freq
				self.p = pos
				self.v = pos*0
				return self
			end

			function Spring:Update(dt, goal)
				local f = self.f*2*pi
				local p0 = self.p
				local v0 = self.v

				local offset = goal - p0
				local decay = exp(-f*dt)

				local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
				local v1 = (f*dt*(offset*f - v0) + v0)*decay

				self.p = p1
				self.v = v1

				return p1
			end

			function Spring:Reset(pos)
				self.p = pos
				self.v = pos*0
			end
		end

		------------------------------------------------------------------------

		local cameraPos = Vector3.new()
		local cameraRot = Vector2.new()
		local cameraFov = 0

		local velSpring = Spring.new(VEL_STIFFNESS, Vector3.new())
		local panSpring = Spring.new(PAN_STIFFNESS, Vector2.new())
		local fovSpring = Spring.new(FOV_STIFFNESS, 0)

		------------------------------------------------------------------------

		local Input = {} do
			local thumbstickCurve do
				local K_CURVATURE = 2.0
				local K_DEADZONE = 0.15

				local function fCurve(x)
					return (exp(K_CURVATURE*x) - 1)/(exp(K_CURVATURE) - 1)
				end

				local function fDeadzone(x)
					return fCurve((x - K_DEADZONE)/(1 - K_DEADZONE))
				end

				function thumbstickCurve(x)
					return sign(x)*clamp(fDeadzone(abs(x)), 0, 1)
				end
			end

			local gamepad = {
				ButtonX = 0,
				ButtonY = 0,
				DPadDown = 0,
				DPadUp = 0,
				ButtonL2 = 0,
				ButtonR2 = 0,
				Thumbstick1 = Vector2.new(),
				Thumbstick2 = Vector2.new(),
			}

			local keyboard = {
				W = 0,
				A = 0,
				S = 0,
				D = 0,
				E = 0,
				Q = 0,
				U = 0,
				H = 0,
				J = 0,
				K = 0,
				I = 0,
				Y = 0,
				Up = 0,
				Down = 0,
				LeftShift = 0,
				RightShift = 0,
			}

			local mouse = {
				Delta = Vector2.new(),
				MouseWheel = 0,
			}

			local NAV_GAMEPAD_SPEED  = Vector3.new(1, 1, 1)
			local NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
			local PAN_MOUSE_SPEED    = Vector2.new(1, 1)*(pi/64)
			local PAN_GAMEPAD_SPEED  = Vector2.new(1, 1)*(pi/8)
			local FOV_WHEEL_SPEED    = 1.0
			local FOV_GAMEPAD_SPEED  = 0.25
			local NAV_ADJ_SPEED      = 0.75
			local NAV_SHIFT_MUL      = 0.25

			local navSpeed = 1

			function Input.Vel(dt)
				navSpeed = clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

				local kGamepad = Vector3.new(
					thumbstickCurve(gamepad.Thumbstick1.x),
					thumbstickCurve(gamepad.ButtonR2) - thumbstickCurve(gamepad.ButtonL2),
					thumbstickCurve(-gamepad.Thumbstick1.y)
				)*NAV_GAMEPAD_SPEED

				local kKeyboard = Vector3.new(
					keyboard.D - keyboard.A + keyboard.K - keyboard.H,
					keyboard.E - keyboard.Q + keyboard.I - keyboard.Y,
					keyboard.S - keyboard.W + keyboard.J - keyboard.U
				)*NAV_KEYBOARD_SPEED

				local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

				return (kGamepad + kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
			end

			function Input.Pan(dt)
				local kGamepad = Vector2.new(
					thumbstickCurve(gamepad.Thumbstick2.y),
					thumbstickCurve(-gamepad.Thumbstick2.x)
				)*PAN_GAMEPAD_SPEED
				local kMouse = mouse.Delta*PAN_MOUSE_SPEED
				mouse.Delta = Vector2.new()
				return kGamepad + kMouse
			end

			function Input.Fov(dt)
				local kGamepad = (gamepad.ButtonX - gamepad.ButtonY)*FOV_GAMEPAD_SPEED
				local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
				mouse.MouseWheel = 0
				return kGamepad + kMouse
			end

			do
				local function Keypress(action, state, input)
					keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
					return Enum.ContextActionResult.Sink
				end

				local function GpButton(action, state, input)
					gamepad[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
					return Enum.ContextActionResult.Sink
				end

				local function MousePan(action, state, input)
					local delta = input.Delta
					mouse.Delta = Vector2.new(-delta.y, -delta.x)
					return Enum.ContextActionResult.Sink
				end

				local function Thumb(action, state, input)
					gamepad[input.KeyCode.Name] = input.Position
					return Enum.ContextActionResult.Sink
				end

				local function Trigger(action, state, input)
					gamepad[input.KeyCode.Name] = input.Position.z
					return Enum.ContextActionResult.Sink
				end

				local function MouseWheel(action, state, input)
					mouse[input.UserInputType.Name] = -input.Position.z
					return Enum.ContextActionResult.Sink
				end

				local function Zero(t)
					for k, v in pairs(t) do
						t[k] = v*0
					end
				end

				function Input.StartCapture()
					ContextActionService:BindActionAtPriority("FreecamKeyboard", Keypress, false, INPUT_PRIORITY,
						Enum.KeyCode.W, Enum.KeyCode.U,
						Enum.KeyCode.A, Enum.KeyCode.H,
						Enum.KeyCode.S, Enum.KeyCode.J,
						Enum.KeyCode.D, Enum.KeyCode.K,
						Enum.KeyCode.E, Enum.KeyCode.I,
						Enum.KeyCode.Q, Enum.KeyCode.Y,
						Enum.KeyCode.Up, Enum.KeyCode.Down
					)
					ContextActionService:BindActionAtPriority("FreecamMousePan",          MousePan,   false, INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
					ContextActionService:BindActionAtPriority("FreecamMouseWheel",        MouseWheel, false, INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
					ContextActionService:BindActionAtPriority("FreecamGamepadButton",     GpButton,   false, INPUT_PRIORITY, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY)
					ContextActionService:BindActionAtPriority("FreecamGamepadTrigger",    Trigger,    false, INPUT_PRIORITY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonL2)
					ContextActionService:BindActionAtPriority("FreecamGamepadThumbstick", Thumb,      false, INPUT_PRIORITY, Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2)
				end

				function Input.StopCapture()
					navSpeed = 1
					Zero(gamepad)
					Zero(keyboard)
					Zero(mouse)
					ContextActionService:UnbindAction("FreecamKeyboard")
					ContextActionService:UnbindAction("FreecamMousePan")
					ContextActionService:UnbindAction("FreecamMouseWheel")
					ContextActionService:UnbindAction("FreecamGamepadButton")
					ContextActionService:UnbindAction("FreecamGamepadTrigger")
					ContextActionService:UnbindAction("FreecamGamepadThumbstick")
				end
			end
		end

		local function GetFocusDistance(cameraFrame)
			local znear = 0.1
			local viewport = Camera.ViewportSize
			local projy = 2*tan(cameraFov/2)
			local projx = viewport.x/viewport.y*projy
			local fx = cameraFrame.rightVector
			local fy = cameraFrame.upVector
			local fz = cameraFrame.lookVector

			local minVect = Vector3.new()
			local minDist = 512

			for x = 0, 1, 0.5 do
				for y = 0, 1, 0.5 do
					local cx = (x - 0.5)*projx
					local cy = (y - 0.5)*projy
					local offset = fx*cx - fy*cy + fz
					local origin = cameraFrame.p + offset*znear
					local part, hit = workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
					local dist = (hit - origin).magnitude
					if minDist > dist then
						minDist = dist
						minVect = offset.unit
					end
				end
			end

			return fz:Dot(minVect)*minDist
		end

		------------------------------------------------------------------------

		local function StepFreecam(dt)
			local vel = velSpring:Update(dt, Input.Vel(dt))
			local pan = panSpring:Update(dt, Input.Pan(dt))
			local fov = fovSpring:Update(dt, Input.Fov(dt))

			local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))

			cameraFov = clamp(cameraFov + fov*FOV_GAIN*(dt/zoomFactor), 1, 120)
			cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
			cameraRot = Vector2.new(clamp(cameraRot.x, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.y%(2*pi))

			local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*NAV_GAIN*dt)
			cameraPos = cameraCFrame.p

			Camera.CFrame = cameraCFrame
			Camera.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
			Camera.FieldOfView = cameraFov
		end

		------------------------------------------------------------------------

		local PlayerState = {} do
			local mouseIconEnabled
			local cameraSubject
			local cameraType
			local cameraFocus
			local cameraCFrame
			local cameraFieldOfView
			local screenGuis = {}
			local coreGuis = {
				Backpack = true,
				Chat = true,
				Health = true,
				PlayerList = true,
			}
			local setCores = {
				BadgesNotificationsActive = true,
				PointsNotificationsActive = true,
			}

			-- Save state and set up for freecam
			function PlayerState.Push()
				for name in pairs(coreGuis) do
					coreGuis[name] = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType[name])
					StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], false)
				end
				for name in pairs(setCores) do
					setCores[name] = StarterGui:GetCore(name)
					StarterGui:SetCore(name, false)
				end
				local playergui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
				if playergui then
					for _, gui in pairs(playergui:GetChildren()) do
						if gui:IsA("ScreenGui") and gui.Enabled then
							screenGuis[#screenGuis + 1] = gui
							gui.Enabled = false
						end
					end
				end

				cameraFieldOfView = Camera.FieldOfView
				Camera.FieldOfView = 70

				cameraType = Camera.CameraType
				Camera.CameraType = Enum.CameraType.Custom

				cameraSubject = Camera.CameraSubject
				Camera.CameraSubject = nil

				cameraCFrame = Camera.CFrame
				cameraFocus = Camera.Focus

				mouseIconEnabled = UserInputService.MouseIconEnabled
				UserInputService.MouseIconEnabled = false

				mouseBehavior = UserInputService.MouseBehavior
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end

			-- Restore state
			function PlayerState.Pop()
				for name, isEnabled in pairs(coreGuis) do
					StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], isEnabled)
				end
				for name, isEnabled in pairs(setCores) do
					StarterGui:SetCore(name, isEnabled)
				end
				for _, gui in pairs(screenGuis) do
					if gui.Parent then
						gui.Enabled = true
					end
				end

				Camera.FieldOfView = cameraFieldOfView
				cameraFieldOfView = nil

				Camera.CameraType = cameraType
				cameraType = nil

				Camera.CameraSubject = cameraSubject
				cameraSubject = nil

				Camera.CFrame = cameraCFrame
				cameraCFrame = nil

				Camera.Focus = cameraFocus
				cameraFocus = nil

				UserInputService.MouseIconEnabled = mouseIconEnabled
				mouseIconEnabled = nil

				UserInputService.MouseBehavior = mouseBehavior
				mouseBehavior = nil
			end
		end

		local function StartFreecam()
			local cameraCFrame = Camera.CFrame
			cameraRot = Vector2.new(cameraCFrame:toEulerAnglesYXZ())
			cameraPos = cameraCFrame.p
			cameraFov = Camera.FieldOfView

			velSpring:Reset(Vector3.new())
			panSpring:Reset(Vector2.new())
			fovSpring:Reset(0)

			PlayerState.Push()
			RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, StepFreecam)
			Input.StartCapture()
		end

		local function StopFreecam()
			Input.StopCapture()
			RunService:UnbindFromRenderStep("Freecam")
			PlayerState.Pop()
		end

		------------------------------------------------------------------------

		do
			local enabled = false

			local function ToggleFreecam()
				if enabled then
					StopFreecam()
				else
					StartFreecam()
				end
				enabled = not enabled
			end

			local function CheckMacro(macro)
				for i = 1, #macro - 1 do
					if not UserInputService:IsKeyDown(macro[i]) then
						return
					end
				end
				ToggleFreecam()
			end

			local function HandleActivationInput(action, state, input)
				if state == Enum.UserInputState.Begin then
					if input.KeyCode == FREECAM_MACRO_KB[#FREECAM_MACRO_KB] then
						CheckMacro(FREECAM_MACRO_KB)
					end
				end
				return Enum.ContextActionResult.Pass
			end

			ContextActionService:BindActionAtPriority("FreecamToggle", HandleActivationInput, false, TOGGLE_INPUT_PRIORITY, FREECAM_MACRO_KB[#FREECAM_MACRO_KB])
		end
	end))
	for i,v in pairs(mas:GetChildren()) do
		v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
		pcall(function() v:MakeJoints() end)
	end
	mas:Destroy()
	for i,v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end
end

return module
